module uart_tx #(parameter CLKS_PER_BIT = 87)
(
    input clk,
    input rst,
    input tx_start,
    input [7:0] tx_data,
    output reg tx_serial,
    output reg tx_done
);

localparam IDLE  = 2'b00;
localparam START = 2'b01;
localparam DATA  = 2'b10;
localparam STOP  = 2'b11;

reg [1:0] state;
reg [15:0] clk_count;
reg [2:0] bit_index;
reg [7:0] data_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        tx_serial <= 1'b1;
        tx_done <= 0;
        clk_count <= 0;
        bit_index <= 0;
    end else begin
        case (state)

        IDLE: begin
            tx_serial <= 1'b1;
            tx_done <= 0;
            clk_count <= 0;
            bit_index <= 0;
            if (tx_start) begin
                data_reg <= tx_data;
                state <= START;
            end
        end

        START: begin
            tx_serial <= 1'b0;
            if (clk_count < CLKS_PER_BIT-1)
                clk_count <= clk_count + 1;
            else begin
                clk_count <= 0;
                state <= DATA;
            end
        end

        DATA: begin
            tx_serial <= data_reg[bit_index];
            if (clk_count < CLKS_PER_BIT-1)
                clk_count <= clk_count + 1;
            else begin
                clk_count <= 0;
                if (bit_index < 7)
                    bit_index <= bit_index + 1;
                else begin
                    bit_index <= 0;
                    state <= STOP;
                end
            end
        end

        STOP: begin
            tx_serial <= 1'b1;
            if (clk_count < CLKS_PER_BIT-1)
                clk_count <= clk_count + 1;
            else begin
                tx_done <= 1'b1;
                state <= IDLE;
            end
        end

        endcase
    end
end

endmodule



module uart_rx #(parameter CLKS_PER_BIT = 87)
(
    input clk,
    input rst,
    input rx_serial,
    output reg [7:0] rx_data,
    output reg rx_done
);

localparam IDLE  = 2'b00;
localparam START = 2'b01;
localparam DATA  = 2'b10;
localparam STOP  = 2'b11;

reg [1:0] state;
reg [15:0] clk_count;
reg [2:0] bit_index;
reg [7:0] data_reg;

always @(posedge clk or posedge rst) begin
    if (rst) begin
        state <= IDLE;
        rx_done <= 0;
        clk_count <= 0;
        bit_index <= 0;
    end else begin
        case (state)

        IDLE: begin
            rx_done <= 0;
            clk_count <= 0;
            bit_index <= 0;
            if (rx_serial == 0)
                state <= START;
        end

        START: begin
            if (clk_count == (CLKS_PER_BIT/2)) begin
                if (rx_serial == 0) begin
                    clk_count <= 0;
                    state <= DATA;
                end else
                    state <= IDLE;
            end else
                clk_count <= clk_count + 1;
        end

        DATA: begin
            if (clk_count < CLKS_PER_BIT-1)
                clk_count <= clk_count + 1;
            else begin
                clk_count <= 0;
                data_reg[bit_index] <= rx_serial;
                if (bit_index < 7)
                    bit_index <= bit_index + 1;
                else begin
                    bit_index <= 0;
                    state <= STOP;
                end
            end
        end

        STOP: begin
            if (clk_count < CLKS_PER_BIT-1)
                clk_count <= clk_count + 1;
            else begin
                rx_data <= data_reg;
                rx_done <= 1'b1;
                state <= IDLE;
            end
        end

        endcase
    end
end

endmodule



module uart_top #(parameter CLKS_PER_BIT = 87)
(
    input clk,
    input rst,
    input tx_start,
    input [7:0] tx_data,
    output [7:0] rx_data,
    output rx_done
);

wire tx_wire;

uart_tx #(CLKS_PER_BIT) TX (
    .clk(clk),
    .rst(rst),
    .tx_start(tx_start),
    .tx_data(tx_data),
    .tx_serial(tx_wire),
    .tx_done()
);

uart_rx #(CLKS_PER_BIT) RX (
    .clk(clk),
    .rst(rst),
    .rx_serial(tx_wire),
    .rx_data(rx_data),
    .rx_done(rx_done)
);
